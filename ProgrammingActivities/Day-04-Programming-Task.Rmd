---
title: "In-Class Computing Day 4"
author: 'Math 253: Statistical Computing & Machine Learning'
params:
  show_answers: no
output:
  tufte::tufte_html: default
  tufte::tufte_handout:
    latex_engine: xelatex
  tufte::tufte_book:
    latex_engine: xelatex
---

```{r include=FALSE}
library(scoreActivity)
```

Today's programming tasks provide an introduction to the basic building blocks of graphics: frames, points, lines, and polygons.  In practice, you'll use higher-level graphics systems such as provided by `lattice`, `ggplot2`, `ggvis` and similar packages.  But you'll understand the use of such packages better if you know the very basics.

## Task 1: The frame

Graphics are drawn in a *frame*.  You can think of this as a piece of paper, a computer screen, or whatever space you like.  In addition to providing the physical space for drawing, the frame defines the *coordinate system* in which graphics are drawn.  We'll work with the most common system: cartesian coordinates.^[There are other coordinate systems, e.g., radial, map projections, etc.]

The basic function to draw frames is `plot()`, part of the `graphics` package that is a part of the standard R distribution.  An empty frame, with axes for the x- and y-axes is generated by this somewhat wordy command:

```{r fig.margin=TRUE, fig.cap="An empty frame.", fig.width=4, fig.height=4.5}
plot(1, xlim = c(0, 100), ylim = c(0,100), type="n")
```
`plot()` doesn't return any value.  It's used for the *side effect* of setting up the graphics display with a frame.

## Task 2

Create two objects named `x1` and `y1` that contain values marking the points at the corner of a square.

```{r echo=params$show_answers}
x1 <- c(50, 80, 80, 50)
y1 <- c(20, 20, 50, 50)
```
Use `lines()` to connect the points in `x1` and `y1`.  Note that `lines()` doesn't close the square.

Create `x2` and `y2` so that `lines()` will draw all four sides of the square.

```{r echo=params$show_answers}
# return to the first point at the end!
x2 <- c(50, 80, 80, 50, 50)
y2 <- c(20, 20, 50, 50, 20)
```

## Task 3


Create objects named `x3` and `y3` that follow a circular path.^[Back to trigonometry!  Use `seq()` to create a set of `angles` from 0 to $2*pi$.  Then `sin()` and `cos()` can convert the angles to the y-coordinate and x-coordinate respectively.]  Center the circle at $(x=50, y=60)$ and give it a diameter of 40.

```{r echo = params$show_answers}
angles <- seq(0, 2 * pi, length = 100)
x3 <- 50 + 20 * cos(angles)
y3 <- 60 + 20 * sin(angles)
```

## Task 4

Create objects named `x4` and `y4` to create a figure-8 shaped path. One way to do this is to use statements similar to those for drawing a circle, but vary the radius at each of the `angles` to be proportional to `abs(sin(angles))`.
```{r echo = params$show_answers}
angles <- seq(0, 2 * pi, length = 50 * pi)
x4 <- 50 + 20 * abs(sin(angles)) * cos(angles)
y4 <- 50 + 20 * abs(sin(angles)) * sin(angles)
```

Use `polygon()` to fill the path created by `x4` and `y4`.




## Task 5

Bells and whistles ...

Often you want to customize graphics, that is, set features of the graphic such as color, axes labels, etc. to values other than their defaults.  

Use each of these optional arguments to customize a graphic:

* `col = ` sets the color of points or lines and the fill of polygons.  Values like "red", "blue", "wheat", etc. can be used.  (Evaluate `colors()` at the console to see a complete list.) If you want a transparent color, use a construction like `col = col2rgb('tomato', alpha = .1)`
* `lwd = ` takes a number indicating line width.
* `pch = ` takes a small integer to set the shape of the point made by `points()`, or a single character, e.g. `x`.
* `xlab = ` and `ylab =` set the x- and y-axis labels repectively
* `xaxt = ` and `yaxt = ` suppress the axis tick marks when set to the value `"n"`.


