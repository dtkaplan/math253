[
["unsupervised-learning.html", "14 Unsupervised learning", " 14 Unsupervised learning "],
["clustering.html", "15 Clustering 15.1 K-means 15.2 Heirarchical clustering 15.3 Example: Gene expression in cancer", " 15 Clustering 15.1 K-means An EM algorithm approach. names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; mod0 &lt;- kmeans(iris %&gt;% select(-Species), centers = 6) To_plot &lt;- iris To_plot$cluster &lt;- letters[mod0$cluster] ggplot(To_plot, aes(x = Sepal.Length, y = Petal.Length, color = cluster, shape = Species)) + geom_point() ggplot(To_plot, aes(x = Sepal.Length, y = Sepal.Width, color = cluster, shape = Species)) + geom_point() load(&quot;Blood-Cell-data.rda&quot;) ggplot(Cells1, aes(x=x1, y=x2)) + geom_point() mod &lt;- kmeans(Cells1 %&gt;% select(x1, x2), centers=8) Cells1$cluster &lt;- letters[mod$cluster] ggplot(Cells1, aes(x=x1, y=x2, color = cluster, shape = class)) + geom_point() 15.2 Heirarchical clustering Linkage Complete: maximum distance between points in the two clusters Single: minimal distance Average: Centroid: center-to-center distance. 15.3 Example: Gene expression in cancer ## Loading required package: ggdendro ## Warning: Setting row names on a tibble is deprecated. "],
["principal-components.html", "16 Principal components", " 16 Principal components Manifolds and planes # Get the party names Parties &lt;- read.csv(&quot;VotesS1-tally.csv&quot;, as.is=TRUE, header=FALSE, nrows=1, stringsAsFactors = FALSE ) # Get rid of the first column and turn into a vector. Parties &lt;- as.character(Parties[,-1]) Votes &lt;- read.csv( &quot;VotesS1-tally.csv&quot;, skip=1 ) Votes &lt;- subset(Votes, complete.cases(Votes) ) rownames( Votes ) &lt;- Votes$VOTE Votes &lt;- Votes[,-1] memberNames &lt;- names(Votes) nBallots &lt;- nrow( Votes ) VotesM &lt;- matrix( unlist( Votes ), nrow=nBallots ) # VotesM &lt;- VotesM[1:nBallots,1:ncol(Votes)] # drop the ballot names # Put in alphabetical order inds &lt;- order( memberNames ) VAlpha &lt;- VotesM[,inds] Parties &lt;- Parties[inds] # remove &lt;- which( apply( VAlpha, 2, function(x) sum(abs(x))) &lt; 100 ) # memberNames &lt;- memberNames[-remove] # Parties &lt;- Parties[-remove] # Valpha &lt;- VAlpha[,-remove] res &lt;- svd( VAlpha ) showVotes &lt;- Votes[,inds] a1 &lt;- res$u[,1,drop=FALSE] b1 &lt;- res$v[,1,drop=FALSE] %&gt;% t a2 &lt;- res$u[,2,drop=FALSE] b2 &lt;- res$v[,2,drop=FALSE] %&gt;% t library(reshape2) # for melt ## ## Attaching package: &#39;reshape2&#39; ## The following object is masked from &#39;package:tidyr&#39;: ## ## smiths melt( VAlpha ) %&gt;% mutate( Vote=factor(value, labels=c(&quot;Nay&quot;,&quot;Abstain&quot;,&quot;Aye&quot;))) %&gt;% ggplot( aes(x=Var1, y=Var2, fill=Vote)) + geom_tile() + xlab(&quot;Ballot&quot;) + ylab(&quot;Member of Parliament&quot;) + scale_fill_manual( values=c(rgb(.2,.2,.2,.6), rgb(.95,.95,.95), rgb(209/255,148/255,12/255))) Random2 &lt;- data.frame( ballot48=VAlpha[48,], ballot118=VAlpha[118,] ) ggplot( Random2, aes(x=ballot48, y=ballot118)) + geom_point( alpha=.7, position=position_jitter(width = .1, height = .1) )+ geom_point( alpha=.01, size=10, color=&quot;red&quot; ) Figure 16.1: Positions of members of parliament on two ballots. Figure 16.2: Positions of members of parliament on two ballot indices made up by the sum of groups of ballots. set.seed(101) Best &lt;- data.frame( one=c(b1), two=c(b2), three=res$v[,3], four=res$v[,4], five=res$v[,5] ) clusts &lt;- kmeans( Best, centers=6) Best$cluster &lt;- as.factor(clusts$cluster) # I lost the first member: Canavan. Figure out later. Best$actualParty &lt;- Parties ggplot( data=Best, aes( x=one, y=two )) + geom_point( shape=1, color=&#39;red&#39;, size=7, aes(x=0,y=0)) + geom_point( size=5, alpha=.6, aes(color=cluster,shape=cluster) ) + xlab(&quot;Best Vector from SVD&quot;) + ylab(&quot;Next Best Vector from SVD&quot;) + ggtitle(&quot;Political Positions of Members of Parliament&quot;) Figure 16.3: The position of each member of Parliament using the two ‘best’ ways of summing the ballots. inds1 &lt;- order(c(res$u[,1])) inds2 &lt;- order(c(res$v[,1])) VA &lt;- VAlpha[ inds1, inds2 ] foo &lt;- data.frame( vote=factor(c(t(VA)), labels=c(&quot;Nay&quot;,&quot;Abstain&quot;,&quot;Aye&quot;)), y=rep(1:134,times=773), x=rep(1:773, each=134) ) ggplot( foo, aes(x=x, y=y, fill=vote)) + geom_tile() + xlab(&quot;Ballot&quot;) + ylab(&quot;Member of Parliament&quot;) + scale_fill_manual( values=c(rgb(.2,.2,.2,.6), rgb(.95,.95,.95), rgb(209/255,148/255,12/255))) "]
]
